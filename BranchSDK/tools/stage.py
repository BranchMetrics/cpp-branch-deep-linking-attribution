#! /usr/bin/env python

import json, os, shutil
from os import makedirs

# Recursively copy src directory into dst directory
# excludes is a list of patterns to exclude
def copyall(src, dst, excludes=[]):
    # ignores is a function to be passed to copytree
    ignores = shutil.ignore_patterns(*excludes)
    all_files = os.listdir(src)
    # rejects is a set of all files matching the excludes
    rejected = ignores(src, all_files)
    files = [f for f in all_files if f not in rejected]

    for f in files:
        path = os.path.join(src, f)
        destination = os.path.join(dst, f)
        if os.path.isdir(path) and os.path.exists(destination):
            # copytree fails if the destination directory already exists.
            # That's the purpose of this function. Call it recursively in
            # this case.
            copyall(path, destination, excludes=excludes)
        elif os.path.isdir(path):
            shutil.copytree(path, destination, ignore=ignores)
        else:
            shutil.copy(path, dst)

# TODO: Collapse this and the above and/or rethink this whole idea, remove conan
# from build process. Makes a flat copy of all *.pdb files from a recursive search.
def copy_pdbs(src, dst, excludes=[]):
    if not os.path.exists(src):
        return

    ignores = shutil.ignore_patterns(*excludes)
    all_files = os.listdir(src)
    # rejects is a set of all files matching the excludes
    rejected = ignores(src, all_files)
    files = [f for f in all_files if f not in rejected]

    # TODO: Use a re with os.path.splitext or something
    for f in [f for f in files if f.endswith(".pdb") or f.endswith(".PDB")]:
        path = os.path.join(src, f)
        shutil.copy(path, dst)

    for d in [f for f in files if os.path.isdir(os.path.join(src, f))]:
        path = os.path.join(src, d)
        copy_pdbs(path, dst, excludes=excludes)

# TODO: Collapse this and the above and/or rethink this whole idea, remove conan
# from build process. Makes a copy of all LICENSE files from the conan source cache.
def copy_licenses(src, dst):
    if not os.path.exists(src):
        return
    all_files = os.listdir(src)

    # TODO: Use a re with os.path.splitext or something
    for f in [f for f in all_files if f == "LICENSE"]:
        path = os.path.join(src, f)
        shutil.copy(path, dst)
        # Expect one LICENSE per package
        return

    for d in [f for f in all_files if os.path.isdir(os.path.join(src, f))]:
        path = os.path.join(src, d)
        copy_licenses(path, dst)

# Generated by conan create
f = open("conan-install.json", "r")
install_data = json.loads(f.read())

installed = install_data["installed"]

# Copy everything under stage (e.g. build\Debugx64\stage)

# Always start fresh
shutil.rmtree("stage", ignore_errors=True)
makedirs("stage/include")
makedirs("stage/lib")
makedirs("stage/licenses")

# Skip Poco's MongoDB and SQLiteData modules, which we don't require.
# Also CppUnit, which one of our deps uses.
excludes = ["CppUnit", "*gtest*", "*gmock*", "*MongoDB*", "*SQLite*", "*Redis*", "*unit_test*", "openssl", "OpenSSL", "zlib"]

for item in installed:
    recipe = item["recipe"]
    print(recipe["id"])

    package_name = recipe["name"]

    for package in item["packages"]:
        # headers and libs are under rootpath
        rootpath = package["cpp_info"]["rootpath"]
        build_id = package["id"]

        print(" " + rootpath + " -> stage")

        copyall(rootpath + "/include", "stage/include", excludes=excludes)
        copyall(rootpath + "/lib", "stage/lib", excludes=excludes)

        copy_licenses(rootpath, "stage/licenses/LICENSE-" + package_name + ".txt")

        # pdbs are under build_path
        build_path = os.path.join((os.path.dirname(os.path.dirname(rootpath))), "build", build_id)
        copy_pdbs(build_path, "stage/lib", excludes=excludes)
