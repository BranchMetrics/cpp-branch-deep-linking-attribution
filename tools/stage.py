#! /usr/bin/env python
# Collects build products into the stage directory

import json, os, shutil, subprocess
from os import makedirs

# Recursively copy src directory into dst directory
# excludes is a list of patterns to exclude
def copyall(src, dst, excludes=[]):
    # ignores is a function to be passed to copytree
    ignores = shutil.ignore_patterns(*excludes)
    all_files = os.listdir(src)
    # rejects is a set of all files matching the excludes
    rejected = ignores(src, all_files)
    files = [f for f in all_files if f not in rejected]

    for f in files:
        path = os.path.join(src, f)
        destination = os.path.join(dst, f)
        if os.path.isdir(path) and os.path.exists(destination):
            # copytree fails if the destination directory already exists.
            # That's the purpose of this function. Call it recursively in
            # this case.
            copyall(path, destination, excludes=excludes)
        elif os.path.isdir(path):
            shutil.copytree(path, destination, ignore=ignores)
        else:
            shutil.copy(path, dst)

def poco_license(dst, rootpath):
    shutil.copy(os.path.join(rootpath, "licenses", "LICENSE"), os.path.join(dst, "POCO_LICENSE.txt"))

def poco_headers(dst, excludes, rootpath):
    # this is the same across all targets
    # only runs once since the include path will exist
    dst_include_path = os.path.join(dst, "include")
    if not os.path.exists(dst_include_path):
        makedirs(dst_include_path)

        # copy headers
        src_include_path = os.path.join(rootpath, "include")
        copyall(src_include_path, dst_include_path, excludes=excludes)

        poco_license(dst, rootpath)

def poco_libs(dst, excludes, rootpath, build_id):
    src_lib_path = os.path.join((os.path.dirname(os.path.dirname(rootpath))), "build", build_id, "build_subfolder", "lib")
    dst_lib_path = os.path.join(dst, "lib", target)
    if not os.path.exists(dst_lib_path):
        makedirs(dst_lib_path)
        
        # copy binaries
        copyall(src_lib_path, dst_lib_path, excludes=excludes)

# copy poco from conan
def copy_poco(src, dst, target):
    print("Copy Poco from conan. " + target)

    # Generated by conan create step in the build script
    f = open(os.path.join(src, target, "conan-install.json"), "r")
    install_data = json.loads(f.read())
    installed = install_data["installed"]

    # Skip Poco libraries we don't use. 
    # Most are excluded at build, but activerecord has a bug.
    # https://github.com/conan-io/conan-center-index/issues/8266
    excludes = [
        "PocoActiveRecord*",  "ActiveRecord", 
        "PocoData*", "Data"
        ]

    for item in installed:
        recipe = item["recipe"]
        recipe_id = recipe["id"]

        # skip everything but poco
        if (not recipe_id.startswith("poco")):
            continue
        for package in item["packages"]:
            rootpath = package["cpp_info"]["rootpath"]
            build_id = package["id"]

            poco_headers(dst, excludes, rootpath)
            poco_libs(dst, excludes, rootpath, build_id)

# copy branch library
def copy_branch_libs(src, dst, target):
    print("Copy Branch SDK. " + target)
    copyall(os.path.join(src, target, "BranchSDK", "lib"), os.path.join(dst, "lib", target))

# recursively copy branch headers
def copy_branch_headers(src, dst):
    print("Copy Branch SDK headers. " + src)
    if not os.path.exists(src):
        return
    if not os.path.exists(dst):
        makedirs(dst)

    files = os.listdir(src)
    for f in files:
        path = os.path.join(src, f)
        destination = os.path.join(dst, f)
        if os.path.isdir(path):
            copy_branch_headers(path, destination)
        elif f.endswith(".h") or f.endswith(".H"):
            shutil.copy(path, dst)

def copy_branch_license(dst):
    print("Copy Branch License")
    shutil.copy("LICENSE", os.path.join(dst, "BRANCH_LICENSE.txt"))

# generate docs and copies them to stage
# requires doxygen to be installed
def build_docs(src, dst):
    print("Build documentation")
    shutil.rmtree(os.path.join(src, "docs"), ignore_errors=True)
    subprocess.run(["doxygen", "Doxyfile"], cwd=src)
    shutil.move(os.path.join(src, "docs"), os.path.join(dst, "docs"))

# paths relative to project root
sdk_path = "BranchSDK"
build_path = "build"
stage_path = "stage"

# create stage
shutil.rmtree(stage_path, ignore_errors=True)
makedirs(stage_path)

# copy source files needed by installer from build to stage
# requires SDK be built for all targets, use build.py

# by default only stage 64 bit binaries
#targets = ["MD_64", "MDd_64", "MT_64", "MTd_64"]
targets = ["MD", "MDd", "MD_64", "MDd_64", "MT", "MTd", "MT_64", "MTd_64"]

for target in targets:
    copy_poco(build_path, stage_path, target)
    copy_branch_libs(build_path, stage_path, target)

copy_branch_headers(os.path.join(sdk_path, "src", "BranchIO"), os.path.join(stage_path, "include", "BranchIO"))
copy_branch_license(stage_path)

build_docs(sdk_path, stage_path)
